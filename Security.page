TODO Nemesis: Preventing Authentication & Access Control Vulnerabilities in Web Applications -zeldovich

resources

- <http://www.cs.berkeley.edu/~daw/teaching/cs261-f08/>

people

- michal zalewski: google security person, wrote browsersec book among tons of
  other literature/tools
- jeremiah grossman: prominent web security blogger; leader of whitehat
  security, purveyor of web application firewalls
- theo de raadt: openssl, openbsd
- mark dowd: amazing; ibm x-force team; taossa book; nacl exploits; flash null
  ptr exploit
- mark miller: exploits, reveng, rootkits; joined windows 8/2008
- james whittaker: testing; joined windows 5/2006; joined google 6/2009
- crispin cowan: stackguard, immunix, subdomain, apparmor; joined windows from
  novell 1/2008
- michael howard: windows security team lead
- niels provos: principal engr at google; libevent, libio, openssh privsep;
  malware work

industry

- infrastructure (network/host) vs (web) application security
  - infrastructure: $9.1B to secure $98.5B assets (9.23%)
  - application: $750M to secure $64.4B assets (1.2%)
  - <http://jeremiahgrossman.blogspot.com/2010/02/infrastructure-vs-application-security.html>

vulnerability databases

- MITRE Common Vulnerabilities and Exposures (CVE)

misc terms

- _side-channel attack_: exploits physical implementation (vs. brute force or theoretical weakness); in crypto
- _covert channel_: channel that draws BW from another channel; in info theory
  - eg timing attacks: latency tells you whether logged in, whether query
    succeeds/fails (document contains term), how much of password you match
    (page-aligning password), etc
- _drive-by download_: browser (or extension) exploit triggered on simply
  displaying a page
- security assurance techniques: pentesting, code review, platform defenses,
  training, architectural/design analysis
- advanced persistent threat (APT): eg chinese gov attacking google

security models

- clark-wilson integrity model: semi-formal model
  - 2 categories of data, known-good (trusted) and unknown (untrusted)
  - mandatory checks to filter data before moving it from unknown to known-good
  - mandatory checks that data must be in the known-good state before it can
    participate in sensitive ops
  - eg: virus scanner than forces checking of all files as they're opened
- bell-lapuda (BPL) privacy model: formal model and policy
  - "data diode": info only flows in not out; useful for eg CIA
  - label-based access control; formal models of security allow for proofs
  - hugely influential in academic security research
- biba integrity model: dual of BPL model, for integrity instead

high level exploit classification

- confused deputy: fool a privileged process to do things for you
- arbitrary code execution: take over and do things yourself

access control

- _discretionary access control (DAC)_: subjects can xfer perms to others;
  decentralized
  - commonly in practice: objs have owners who controls perms
  - capability systems: subjects can xfer perms to others
- _mandatory access control (MAC)_: policy controlled by admin only; centralized
- _role-based (RBAC)_: restrict system access to authorized users
  - newer alt to MAC/DAC; can sim MAC/DAC
  - users are assigned particular roles; roles are assigned permissions
  - basically, roles are a level of indirection
  - qualitatively/typically, more fine-grained than ACLs, enumerating specific
    high-level operations

integrity control TODO

security

- confidentiality: aka privacy, secrecy
- integrity: eg phishing, MITM, hijacking, forgery
- availability: eg DOS

S/MIME: TODO

- http://en.wikipedia.org/wiki/S/MIME
- http://weblog.infoworld.com/udell/2004/03/23.html

C++

- new/delete[]: if eg you have an array created with new[] and then
  accidentally delete[] a pointer not pointing to the head, then you can
  overwrite in the previous element the mem that delete[] treats as the length
  field
  - gcc: delete[] consults vtable of each object indepdently
  - msvc: delete[] consults vtable of first object only
  - harder on msvc, but can still do interesting things if eg dtor itself does
    anything interesting with the object data, eg free a pointer or set a value
- new[]/delete: you can cause coalescing by setting the `prev` bit in the
  malloc header, among other things

high-level code injection, encoding/parsing vulns

- unescaped input
- unicode: bad multibyte chars can bypass poor standard-library
  escapers/filters and validators/scanners unscathed
  - dynamic langs like sql and html/js
  - specific case of parser errors
  - eg: UTF-7
    - can encode ascii, eg `+ADw-` for `<`
    - IE interprets html/javascript using UTF-7 by default, and others use
      UTF-7 if a UTF-7 encoding appears anywhere early on (hence, `title`,
      `meta`, etc are targets)
    - need to check that all places handling this interpret it/escape it
      correctly, eg need to specify UTF-7 to php escaper `htmlentities()`
    - <http://shiflett.org/blog/2005/dec/google-xss-example>
  - eg: multi-byte encoding
    - eg, adding slashes (php `addslashes()`) is insufficient
    - `addslashes("\xbf27")` is '\xbf5c27', and '\xbf5c' is a valid char in
      GBK, swallowing the slash/letting the quote work
    - <http://shiflett.org/blog/2006/jan/addslashes-versus-mysql-real-escape-string>
- parser errors: unhandled cases leading to unesacped input

sandboxing pitfalls

- ptrace: race conditions
  - ptrace behavior: suspends thread; mon reads args (regs, mem) separately
    - monitor can rewrite syscalls
  - multi-threaded arg race (TOCTTOU)
    - A syscalls; monitor checks; B changes args
    - works only on args that are not in regs, eg ptrs to other mem (file paths)
    - heavy-handed soln: prohibit multithreading
    - soln: suspend all threads
      - only for syscalls that use such ptrs ("volatile" syscalls)
      - if block all syscalls, then deadlock
        - devs use syscalls for sync (eg read and write)
        - authors don't know of any such pair of syscalls where one is volatile
  - another process could modify args via shared mem
    - heavy-handed soln: prohibit forking, shared mem
    - soln: or suspend all processes
  - fork-attach race
    - sandbox doesn't immediately attach to a forked child (!)
    - forked child can secretly fork another child monitor won't know about
    - soln: change call from fork to clone; has option to start in ptraced mode
  - FS race: trickiest; use symlinks to break security
    - prisoner does syscall involving path
    - monitor looks up path, following symlinks, to verify
    - another process/thread replaces a component in path with symlink to
      secure region in FS (eg user's $HOME)
    - soln: suspend threads
  - signals TODO
    - avoid by denying signals
  - alts to syscalls
    - lcall7 and lcall27 call gates; removed from most modern linuxes
  - MITRE CVE has over 40 ptrace-related items
  - refs
    - <http://iacoma.cs.uiuc.edu/~greskamp/pdfs/598cz.pdf>
    - NaCl
- chroot
  - TODO
  - (obv) can still make arbitrary syscalls; FS is only one part of sandboxing

web

- flash: `<embed...allowScriptAccess="always">` instead of `"sameDomain"`
- _HTTP parameter pollution (HPP)_ variants: multi-value, OOO value, malformed
  value, malformed request methods
- clickjacking: tricking the user into clicking something on a target site
  - eg by loading target in transparent iframe overlaid atop an enticing
    button, with a form submission button positioned exactly at the right place
  - mitigations: framekiller or framebuster: check `top==self`

low-level exploits

- buffer overflow
  - defenses
    - stack canaries: choose random int at process start and insert before
      return addr
      - random xor canaries: xor with the return addr to make sure it's not
        tampered with
      - propolice: gcc's impl; enhanced version of stackguard (never officially
        impl'd in gcc)
      - visual studio: /gs
    - nonexecutable stack: in windows, called Data Execution Prevention
      - NX bit: in page table entries; XD bit in intel, enhanced virus
        protection in amd
      - segments can be readable/writeable/executable, but modern OS's use flat
        memory model (pages instead of segments)
    - address space layout randomization (ASLR): randomize codes, heap, stacks
      - against return-to-libc (arbitrary code can still detect things)
- null pointer exploits: TODO
- heap overflow: overwrite eg a struct's function pointer or malloc block
  header
- heap spray: give you a place to place executable code, eg if stack is NX or
  your overriding return addr is constrained somehow
  - spray it everywhere to increase chances of landing in it
  - common in web browser js engines
  - nozzle: msr project that uses sled detection then reduces false positive
    rate with "global heap health metric"
- parser errors: unhandled cases
- format string attacks: eg printf(untrusted_input())
  - eg use %s and %x to print data from stack or other memory locations
  - defenses: statically check format strings
- integer overflow: unexpected number, either negative or large
  - eg size header in messages
  - controls things like strncpy/memcpy for overwrites
  - controls allocations (malloc) for large, unrealizeable mallocs that return
    null
  - also, arithm overflow
- null pointers
  - as write vector: use bad alloc to get ptr = null, where app later does
    *(ptr + offset) = value (where offset and value are user-controlled) to
    write a function ptr (flash exploit)
  - if the ptr is dereferenced and fields are accessed, first prep by writing
    to those fields
- return-to-libc: execute existing code via return ptr, circumventing NX
  - eg `system("bash")`
  - ASLR defends against this
  - techniques to make multiple function calls:
    - `%esp` lifting: for `-fomit-frame-pointer`
      - functions end in `addl $LOCAL_VARS_SIZE, %esp; ret`
      - after args to function, pad enough so that next function ptr is where
        %esp would point and thus the system would return to
    - frame faking: for programs w frame pointer
      - functions end in `leave; ret`
      - put in fake `ebp`s (frame ptrs) that point to function, followed by a
        ptr to a `leave;ret`
      - the very first return should point to a `leave;ret`
return oriented programming

- _continuation of execution_: resume app normally after exploit payload

same-origin policy (SOP)

- policies
  - for DOM access: scripts can access another page's functions/data iff from
    same site (in another frame/window)
    - scripts run in context of includer, not source; can't xhr or DOM-manip
      google
  - for XHR: only time when SOP restrict doc retrieval; html elements can
    source any domain
  - for cookies
  - for flash
    - `crossdomain.xml`: primarily protects access to the host containing the
      `crossdomain.xml`, specified with `allow-access-from`
      - careless wildcard usage opens up holes; eg flickr's api (since isolated
        to a separate domain)
    - can make same-origin HTTP reqs
    - can make same-host TCP conns on any high port
  - for java: applets can only see site it's downloaded from
    - can interact with the embedding page via JSObject API iff `mayscript` set
      in `applet` tag
    - DOMService API allows cross-site embedding pages to be accessed freely!
      with no `mayscript` opt-in, directly contradicting JSObject API
    - ability to send same-origin HTTP reqs using browser stack via
      URLConnection API; can even set `Host` headers or conflicting caching
      directives
    - unconstrained TCP connections back to originating host
  - for silverlight: mimicks flash
- attacks against SOP: XSRF, XSS, DNS rebinding
- rules
  - match: (domain name, app layer protocol (http/ftp), tcp port)
  - opt to communicate by setting `document.domain` to same right-hand fragment
    of current host name (eg en.example.com and fr.example.com set to
    example.com)
  - corollary: all subdomains are implicitly granted accessed to parent domain
- workarounds
  - google analytics works by issuing a single-pixel image request containing
    all collected information
  - google maps api works by dynamically creating script tags that load
    on-demand javascript (data can be in JSON)
  - flash: permits cross-domain requests if allowed by crossdomain.xml on
    target webserver
- threat model: defend against impersonation of user and impersonation of site
- some operations still allowed
  - include scripts across domains
  - submit POST forms across domains
- mitigation practices
  - escaping/filtering
  - input validation
  - http responses are variations
  - http request smuggling

ways to do cross-site communication in web apps

- dynamically create script tags to get data
  - unsafe: response can do arbitrary code execution
- Mozilla cross-window messaging via `window.postMessage`
  - receiver gets `message` DOM event; msg contains data, domain, uri, source
  - allows cross-site communication
  - requires explicit msg handling on target page, so less susceptible to
    problems than unchecked shared DOM access (pre-SOP)
- JSONRequest: obsoleted by CS-XHR
  - like form.submit, but no auth data or cookies
- IE XDomainRequest (XDR) and W3C Cross-Origin Resource Sharing (CORS)
  - send `Origin` in req (like `Referer` but no path)
  - require `Access-Control-Allow-Origin` in response; must be `*` or the exact
    page URL
  - CORS is for XmlHttpRequest Level 2, namely the Cross Site-XHR (CS-XHR) part
    (XHR2 bundles many features)
  - IE team criticizes CS-XHR in favor of XDR
  - spec says JSONRequest doesn't address their requirements
- Flash, Silverlight: similar server-side sandboxing as XDR/CORS using
  `crossdomain.xml`
- <http://blogs.msdn.com/ie/archive/2008/06/23/securing-cross-site-xmlhttprequest.aspx>

web application security

- mozilla content security policy (CSP)
  - no inline scripts, only included script files from whitelisted sites
  - no code from strings: eval, setTimeout-with-string, etc.
  - specify where content allowed from/where requests can be sent
  - see examples on <https://wiki.mozilla.org/Security/CSP/Spec>
- html5 sandboxing
  - sandbox tag treats its contents as different-origin
- session attacks to obtain session ids
  - prediction
  - capture
  - fixation: get user to use an attacker-chosen sid
- web application firewalls (WAFs)
  - modsecurity: for apache; supports negative & positive rule models; has core rule set; non-learning
    - http compliance
    - automation detection
    - owasp top 10 attacks (sql, xss, os cmds, filenames, cf/asp/php, email, response splitting, pdf)
    - comm w trojans/backdoors that have already broken in
    - app error hiding
    - external patching

secure javascript

- caja
- secure ecmascript: <http://ses.json.org/>

javascript

- ESAPI: an encoding lib that uses declarative rules and whitelists of allowed
  chars

XSS (cross-site scripting)

- exploits the trust that a user has for a particular site
- name origins: malicious site loads another site in a frame/window, then use
  js to read/write data; blocked by SOP
- now: code (html/js) injection into pages (eg forum) viewed by others (to
  read/write data)
  - frequently: hijack session key; send by embedding in (eg) img url
- types
  - non-persistent aka reflected: request is instantly and transiently used
    (not stored) to return result, eg search engine box
    - only affects the requester, but social engineering (eg send link)
    - most common, but importance is arguable (due to soc eng requirement)
  - persistent aka stored aka second-order: request is stored & later
    displayed (to others)
  - DOM-based aka local: TODO
    - orthogonal to persistence
- 80% of all sec vulns in 2007 -symantec

XSRF (cross-site request forgery)

- exploits the trust that a site has for a particular user
- before SOP, easy for evil.com to use XHRs to send requests to bank.com that
  carry cookies and auth data
- make user's browser send request to a site that user has active credentials
  on
- examples
  - malicious site contains form that entices user to submit
    - POSTs to bank site withdrawing money
    - requires user to be authenticated
  - post img to bank site forum whose src is a GET that (eg) withdraws money
- fixes
  - referer checking: subject to SOP implementation vulnerabilities, but more
    importantly referer-filtering (many enable this for privacy)
  - use nonces to make each http response-http request a challenge-response
    - as long as you use something secret to the outside world, you're fine
    - so you can either generate random numbers
    - or you can use the session ID (or a hash of it to reduce the chances that
      it gets leaked)
    - GET requests are tricky because you can read the URL out of the location
      bar

pluggable authentication module (PAM)

- first in linux (linux-pam from RH), but on other systems now

PKI

- TLS/SSL certificates
  - standard: cheaper, faster; just shows padlock
  - extended: more rigorous issuing policy; also shows company name
  - CAs sell packages: single domain, $n$ domains, wildcard (subdomains)
- SNI: extension to TLS that enables virtual hosting
  - client requests name of virtual domain during TLS nego
- certificate revocation list (CRL)
  - published by the issuing CA on some periodic schedule
  - clients download, cache, check against it
- online certificate status protocol (OCSP): check online if cert still good
  - less BW (don't DL all), real-time
  - impl'd in major browsers
- X509 certificate formats
  - pem: base64, with "BEGIN/END CERTIFICATE"; for DEM certs; originally for
    privacy enhanced mail
  - cer, crt, der: usually in binary DER format
  - p12: PKCS12, may contain both public and private keys; published by RSA
    - protected with password-based symmetric key
    - successor to PFX from MS, criticized for complexity

- MAC: integrity and authenticity; TODO
- message authentication code (MAC): keyed hash; TODO
- message integrity code (MIC): TODO
- hash-based MAC (HMAC)
  - uses 1-way hash (eg SHA), but incorporates shared secret key (for
    authenticity) and re-hashing the hash of the key + message (to prevent
    append attacks)
  - masks key with consts ipad (0x3636..) and opad (0x5c5c..)
  - hmac(key, msg) = hash((key xor opad) + hash((key xor ipad) + msg))
  - <http://dev.ionous.net/2009/03/hmac-vs-raw-sha-1.html>
- cryptographic hash functions: TODO
- diffie-hellman key exchange
  - allow 2 parties w no prior knowledge of ea other to establish shared secret
    key over insecure channel
  - uses discrete logarithm problem: compute discrete logs module an
    appropriate prime (a bit harder/slower than factoring "hard" ints of same
    size)
  - followed shortly by RSA
- secure remote password (SRP)
  - structurally similar to D-H

- salting: decorating a password (eg prefix/suffix) and hashing that as the
  "password" (for storage/comparison); similar to nonce
  - defends against rainbow table attacks (since each user)
  - variations
    - site-wide, static hash (hardcoded)
    - hash of user info; lacks entropy, still can be predicted (only so many
      usernames)
    - generate and store random salt
    - combo of above: static + user info hash + stored hash

network attacks

- sockstress: syn-synack-ack flood (local iptables configured to not be
  affected)
- ping of death: icmp packet that's >64KB in length
- teardrop: mangled IP fragments with overlapping, over-sized payloads

network reconnaissance

- idle scan aka zombie scan: port scan that doesn't reveal scanner's IP to
  target by using intermediate node ("zombie")
  - attacker sends SYNACK to zombie to get its IP ID (eg 31337)
  - attacker sends SYN to target spoofed from zombie; if port is open, target
    sends SYNACK to zombie
  - zombie sends RST to target since that's what TCP does on unsolicited
    SYNACK; this has IP ID 31338
  - attacker sends SYNACK to zombie again to get its new IP ID 31339
  - if port wasn't open, attacker's subsequent SYNACK would get 31338

network security tools

- nessus: vuln scanner
- wireshark: packet analyzer
- snort: IDS
- netcat: swiss army knife
- metasploit: dev framework for exploits
- hping, nmap: network probing
- kismet: wifi sniffer
- tcpdump: packet capture
- cain & abel: windows password recovery
- john the ripper: unix password recovery
- <http://sectools.org/>

network hijacking

- TCP hijacking
  - if on same segment: easy to just observe seqno and spoof it
  - if on diff segment: need to guess initial seqno
- IP/BGP/prefix hijacking: take over groups of IPs by corrupting Internet
  routing tables
  - announce a prefix that it you don't actually own
  - announce a more specific prefix than the true owner's prefix
  - announce that you have a shorter route to the target AS
  - "black holing": ??
  - must hijack BGP TCP session
- DNS cache poisoning: tricking NS into thinking it got authentic info
  - specify attacker's choosing of authority NS for either requested domain or
    unrelated domains
  - bugs in eg BIND allowed the above to slip by; now fixed
  - still, no signing means easy to do MITM
  - DNSSEC signs responses with PKI
- DNS rebinding: trick browser into combining diff hosts into 1 origin
  - circumvent firewalls; access internal sites
  - steps
    - register domain
    - use own DNS server; set short TTL (1s)
    - attract traffic (run ads)
    - serve page w JS that issues another request to domain after TTL (2s),
      triggering DNS query
    - rebind hostname to internal IP (10.10.10.10)
    - send response to attacker
  - DNS pinning: some browsers (IE) cache for add'l min time (30m)
    - still re-queries if can't connect to host
    - hence, after initial page load, firewall off the client; rebind works
- wifi
  - karma: listen for wifi client probes so that you can eg pretend to be a
    familiar AP
  - airdrop-ng: deauthorization tool to disassociate APs and clients
- dhcp exhaustion: silence the orig dhcp server, then become mitm dhcp server
  that dishes out your own gateway, dns, etc; there's a metasploit module

brute-force DOS

- flooding
- DDOS
- easy to detect (? TODO)

sophisticated DOS

- app bugs: eg buffer overflows
- fragmentation of data structures: eg hash tables
- algorithm worst cases, eg regexes

public key crypto

- rsa
- dsa
- elliptic curve
  - attractive for mobile/wireless env's
  - vs RSA: equiv security with smaller key sizes (faster, less resources)

block ciphers vs. stream ciphers

- distinction not always clear cut; block ciphers sometimes act effectively as
  stream ciphers
- stream ciphers usu. faster, but serious sec problems if used incorrectly
  (esp: same starting state must never be reused)

stream ciphers

- _stream cipher_: symmetric key cypher where plaintext is combined with
  pseudorandom cipher bit stream called _keystream_, typically xor
  - plaintext bits encrypted one at a time
  - xform varies during encryption
- rc4: by ron rivest; in (eg) WEP, WPA (default), TLS/SSL (opt), BT, ssh (opt),
  RDP, KRB (opt), PDF
- a5/1: in GSM; in US, EU; leaked, rev-eng'd; numerous weaknesses
  - can decrypt GSM phone calls in real time
  - <http://www.schneier.com/blog/archives/2008/02/cryptanalysis_o_1.html>
- a5/2: a5/1 with deliberate weakening for certain export regions

block ciphers

- _block cipher_: operate on large blocks of digits with a fixed, unvarying
  xformation
  - eg 128-bit blocks of plaintext -> 128-bit blocks of ciphertext
- des: early highly influential; ibm; 1997; insecure to brute force
  - EFF DES cracker aka "deep crack": cracking machine
  - with distributed.net, decryted challenge 3 after just 22h
  - controversy over NSA's opaque involvement in design
- 3des: 1998; applies des 3x per block; used by electronic payments industry
  - simply increases key size 3x to defend against brute force
  - pseudocde: des_enc(k1) -> des_dec(k2) -> des_enc(k3)
- blowfish: bruce schneier; 1993; fast; no known cryptanalysis; widely used,
  but aes overshadows it
- aes aka rijndael: successor to des; 2001
  - 128, 192, 256 bit key sizes; all 128 bit block sizes
- KASUMI aka a5/3 in GSM aka GEA3 in GPRS: no known weaknesses, but GSM is vuln
  (can avoid a5/3)

security status of cryptographic tools

- insecure: MD5, SHA1
- secure: AES, RSA, SHA-256

cryptographic hash fns

- SHA: NIST-approved
- blowfish: bruce shneier
  - expensive key setup phase

crypt

- uses hash fn, encodes salt, records which hash fn used
  - by default, uses DES on data=0, key=truncated pass
  - other versions exist that use md5, blowfish, sha
- eksblowfish (provos, mazieres, 1999)
  - take adv of expensive key setup phase of blowfish
  - introduce configurable # rounds to make validation arbitrary expensive

block cipher modes

- TODO
- insecure: electronic codebook (ECB)
- output feedback (OFB), cipher feedback (CFB)
  - don't repeat _initialization vector (IV)_ for same encryption key
- cipher block chaining (CBC), propagating CBC (PCBC)
  - use this if msg authenticity is not an issue
- authenticated encryption (AE): simultaneously protect confidentiality and
  integrity
  - CCM, CWC, OCB, EAX, GCM: TODO

VPNs

- point-to-point tunneling protocol (PPTP): microsoft's default VPN
  protocol
  - remains popular
  - protoco-independent, but main usage: TCP control stream, GRE data stream
    (many firewalls don't support GRE)
  - there are alts eg RADIUS but PPTP is default for client back-compat
  - doesn't require PKI, unlike L2TP/IPsec
  - provides confidentiality, not integrity or authentication
  - encapsulates PPP
- layer 2 tunneling protocol (L2TP)
  - derived from PPTP
  - combines control & data channels
  - protocol-indep, but mainly used over UDP 500
  - standards bodies attn shifting toward L2TP from PPTP
  - uses IPsec ESP by default
  - also provides user auth
  - encapsulates PPP
- IPsec
  - provides confidentiality, integrity, authentication
  - uses PKI and machine-level certs
  - doesn't provide user auth
  - TODO
- secure sockets tunneling protocol (SSTP): tunnels over HTTPS (TCP 443)
  - provides confidentiality, integrity, authentication
  - encapsulates PPP
- IKEv2: uses IPsec
  - provides confidentiality, integrity, authentication
  - supports the latest ipsec encryption algos
  - supports mobility (MOBIKE); resilient to changing network connectivity; can
    switch APs or even wired/wireless
- OpenVPN ALS: web-based SSL VPN server written in Java; derived from Adito,
  SSL-Explorer
  - provides in-browser HTTPS client access with java applets for tunneling
- misc
  - PPTP, L2TP, SSTP depend heavily on features orig for PPP
  - built in to windows: PPTP2, L2TP/IPsec, SSTP, IKEv2
  - SSTP, IKEv2, maybe others: don't require client-side PKI deployment or pre-shared key
  - SSTP, IKEv2, maybe others: integrate well w EAP
- refs
  - <http://www.intranetjournal.com/foundation/tunneling.shtml>
  - <http://technet.microsoft.com/en-us/library/dd469817(WS.10).aspx>
  - <http://blogs.technet.com/rrasblog/archive/2009/02/10/do-we-still-need-pptp-l2tp-ipsec-after-windows-7.aspx>

authentication protocols

- EAP
  - authentication framework, not specific mechanism; over 40 methods
  - used in wireless networks and point-to-point conns
  - adopted by WPA, WPA2
- challenge handshake authentication protocol (MS-CHAPv2)
  - the only authentication protocol for windows PPTP
  - uses DES
  - weaknesses known by 1999; bruce schneier and l0pht wrote a
    cryptanalysis
  - username is in plaintext
- lightweight extensible authentication protocol (LEAP): cisco-proprietary
  extension of EAP; in cisco ap's
  - uses modified version of MS-CHAP
- newer: EAP-FAST, PEAP, EAP-TLS
- EAP-TLS: TODO
- u-prove: maintain privacy while proving that i can pay
  - TODO can't tell if same person made txns?

windows security

- 2 ways windows stores acct credentials: LAN Manager and NTLM
  - LAN Manager: weak; brute force, rainbow tables
  - NTLM: time-memory tradeoff attacks

cracking techniques

- brute force
- rainbow tables: sets of precomputed hashes as a time-memory tradeoff

cracking tools

- MS-CHAPv2, LEAP, PPTP
  - ASLEAP: cracks LEAP and PPTP; updated to crack MS-CHAPv2
    - given MS-CHAPv2 challenge and response, return last 2 bytes of password
      hash (username already in plaintext)
  - CUPP: common user password profiler; wizard-like dictionary generator
    that asks for info about user
  - genkeys: generates hashes of a wordlist using DES
  - cowpatty: cracks pre-shared key (PSK) WPA networks based on the TKIP
    protocol
- MD5
  - BarsWF: CUDA-based MD5 cracker; 4B hashes/s with quad SLI;
    <http://3.14.by/en/md5>
- windows: LAN Manager, NTLM
  - pwdump: outputs LM and NTLM account password hashes from the Security
    Account Manager (SAM)
  - CUDA-based NTLM brute forcer for linux:
    <http://3.14.by/forum/viewtopic.php?f=8&t=60&>
  - ophcrack: crack windows passwords using rainbow tables
  - usbophcrack: downloads some rainbow tables and creates boot usb
    - advise using ophcrack's rainbow tables instead
- <http://revision3.com/hak5/asleap>

windows system security

- ASLR
- DEP: uses NX if avail or software emulation with limited, almost-unrelated
  protection with SafeSEH (simply checks that an exception is registered in a
  function table for the app)
- common exploit techniques TODO <http://www.hick.org/~mmiller/shellcode/win32/generic.c>
  - PEB
  - SEH
- steadystate/pc safeguard
  - applied only to std accounts; rolls back all reg, fs changes

windows 7 UAC design flaws

- auto-elevating executables: to reduce annoyance
  - but anyone can run them; at one pt rundll32 was auto-elevating
- auto-elevating components
  - work only when caller is ms-signed exe, eg explorer
  - but procs can inject code into ea other as long as same user
- <http://arstechnica.com/microsoft/news/2009/03/opinion-ms-should-kill-win7-uac.ars>

selinux (nsa 2000; merged mainline 2003)

- supplements unix DAC with MAC
- selinux is an implementation of FLASK for linux
- hybrid of concepts and capabilities from MAC, MIC, RBAC
- hard to config
- applies labels to files
- identifies files by inodes
- perms
  - specify specific ops (creat, rename, unlink, etc)
  - allow, deny, auditallow, auditdeny

linux apparmor (novell 2005)

- supplements unix DAC with MAC
- manually specify profiles for apps
- "learning mode" logs holes that are opened and creates profiles from that
- alternative to selinux
  - identifies files by paths instead of inodes
  - can make use of FSs with no support for extended file attributes, eg NFS

SFI
---

TODO

efficient software-based fault isolation (wahbe, sosp93)

- [aka "classical SFI"]
- isolate software modules without relying on MMU
- naive custom compiler approach: on a write or indirect branch/jump, check that addr is in current module's range
  - slow
  - circumventable; eg, indirect branch to own write that skips the checks before it
- use a dedicated reg to hold an addr
  - all writes must be performed to the addr in the reg
  - reg must always point to valid addr in current module
    - if any instr invalidates this, program must fail or fix by the next write/indir jump
- to jump outside, use local jump table; system allows only this table to point outside
  - allows indir jumps to be very simple: only check for local
  - switch stacks
  - callee-save regs: call stub saves regs in case callee does not preserve regs
- opts
  - checks can be made into a simple bitmask as long as ranges can be identified by bit prefixes
  - stack writes use $esp + small static offsets; hence just validate $esp when it's changed, and pad module space with guard regions that are bigger than biggest offsets
- overhead: 0-12% (avg 4.3%); if also checking reads, avg 21.8%
- [depends on large trusted compiler for correctness; later works like pittsfield use smaller verifier on machine code]
- [not used in practice, maybe bc depends on RISC features like reserving certain regs, maybe bc no robust product]
- [pittsfield, vx32 apply to x86 and have more robust prototypes]
- [vx32 creatively exploits legacy hardware being phased out]
- [SFI has a useful fault iso model that deserves HW support]
- <http://papersincomputerscience.org/2009/12/19/efficient-software-based-fault-isolation/>

pittsfield (stephen mccamant, greg morrisett, TR/usenix 2005)

- SF vs pittsfield: write/jump sandboxing vs full read/write/jump isolation

vx32 (bryan ford, russ cox, TR 2008)

- x86, linux/freebsd

engineering
-----------

<http://www.matasano.com/log/989/thoughts-on-ten-years-of-qmail-security/> (DJB 2007)

- directions of progress
  - eliminating bugs
  - eliminating code
  - eliminating trusted code
  - distractions
    - chasing attackers
    - minimizing privilege: vs minimizing TCB
      - ["privileges" here are superficial OS level privileges]
    - speed
- eliminating bugs
  - enforcing explicit data flow: process isolation, PL support
  - simplifying integer semantics: used big num lib, PL support
  - avoid parsing: anything with strings; quoting; printf bugs
  - generalizing from errors to inputs: insert testable abstractions
- eliminating code
  - identifying common functions
  - automatically handling temporary errors [exceptions better than error checking]
  - reusing network tools [like `inetd`]
  - reusing access controls: eg assuming a user's uid
  - reusing the file system: as an associative array (instead of parsing a
    single config file)
- eliminating trusted code
  - accurately measuring the TCB: hard
  - isolating single-source xforms
    - eg jpegtopnm: after jailing, attacker can only produce any img he wants,
      but he could've done this in the first place
  - delaying multi-source merges (like XSS)

web
---

robust defenses for CSRF (adam barth, collin jackson, john c mitchell, CCS 2008)

- login CSRF
- TODO

sound and precise analysis of web applications for injection vulnerabilities (ucdavis, pldi07)

- prev static approaches use tainted information flow tracking
  - don't model precise semantics: even 'sanitizers' like `escape_quotes` could
    fail to sanitize inputs
  - require manual specifications bc systems don' track string value sources
  - not fully automated and may require user intervention at various points in
    analysis
- consider as attacks those queries for which user input changes the intended
  syntactic structure of the generated query
- implemented for PHP; analyzed large (100KLOC) progs; few false positives

DOS
---

<http://www.checkmarx.com/NewsDetails.aspx?id=23> regex ("redos")

- worst-case exponential
- eg: /^(a+)+$/ on "aaaaX" produces 16 paths
- more: /([a-zA-Z]+)*/, /(a|aa)+/, /(a|a?)+/, /(.*a){x}/ for x>10
- many legit bad regexes even in OWASP validation regex repo
- many pts of attack; regexes are ubiq
  - submit a bad regex or leverage regex injection
  - submit a string for an already-there bad regex
- meta-regex for finding bad regexes; use codesearch to find
- browsers protect against infinite loops but not bad regexes
- should be not-too-bad to statically analyze regexes

fun exploits
------------

morris worm

mark dowd flash exploit 2007

- <http://chargen.matasano.com/chargen/2007/7/3/this-new-vulnerability-dowds-inhuman-flash-exploit.html;jsessionid=8DDE25A54184976447838948127BE85C.web18>
- bounds-checker treats field as signed, permitting (small?) negative numbers
- interpreter treats as unsigned, so neg -> large
- controls alloc, so bad alloc -> null ptr
- flash uses that ptr + attacker-controlled offset
- to that addr, flash writes attacker-controlled value
- idea: use this writing vector to target a function ptr, changing it to a
  user-supplied buffer of shellcode
- tough constraints: offset > 0x80000000, offset + 4 divisible by 12, used
  value = (value cast from 16- to 32-bit) - some other var
- so instead, manipulate actionscript bytecode state
- interpretation differs btwn verifier TOC & executive TOU
  - verifier ignores undefined bytecodes
  - verifier keeps table defining bytecode instruction lengths
  - bytecode length table is valid target of null ptr overwrite
  - executive has totally diff machinery for interpreting bytecode
- use null ptr write vector to clobber the right value in length table, and you
  can make unused instr that the verifier ignores seem much longer than it is
- executive doesn't ignore what comes after the initial unused instr, so put
  valid bytecode there for execution

kernel null pointer exploits

- tun driver uses null ptr; can write to 0x0 with mmap, iff selinux is on,
  ironically
- ptr is used in an exploitable way
- "In well-designed systems, catastrophic failures are rarely the result of a
  single failure. That is certainly the case here."
- <http://lwn.net/Articles/342330/>

IFC
===

general

- [autoescape makes taint mode obsolete for web apps?]

taint mode for python via a library (2010)

- dyntaint: nifty; only does basic taint
- decorators: @untrusted, @ssink(TYPE), @cleaner(SQLI) where TYPE denotes
  channel type with relevant attacks (SQLI, OSI)
- <http://www.juanjoconti.com.ar/2010/07/06/talk-taint-mode-for-python-via-a-library-slides/>

RESIN: Improving Application Security with Data Flow Assertions (alex yip sosp09)

- python-taint: alexyip; requires new interpreter
- _filter objects_ define data flow boundaries on functions, IO channels
  - eg file objects, escape()
  - default set on all standard libs
  - eg filter on http output channel could check for attacks like crlfcrlf
- annotate sensitive data w _policy objects_
  - export_check(ctx) method checks that ctx is suitable to output data to
  - eg for passwd
    - policy object has an email field
    - export_check(ctx) = ctx is email to matching recip, or ctx is http to admin
  - eg user supplied inputs
  - merge(policy_set) method is overridable; defaults to union
- runtime tracks ints, strings (possibly down to individual chars)
  - wraps sql db interfaces to persist policies (rewrites schemas)

DIFC
----

flume

- IFC goals
  - secrecy: prevent leaking private data
  - integrity: prevent accepting untrusted data
- DIFC: decentralized means no central deputy needed for declassification
- flume: DIFC at process granularity, controlling IO; user-level monitor
- related work
  - jif: finer-grained control at function granularity; requires app rewrite
  - asbestos/histar: kernels designed to support DIFC; message granularity
  - flume
    - rules inspired by jif
    - labels influenced by asbestos
    - adopted histar's requirement that threads must explicitly request label changes
- concepts
  - a tag $t$ is associated with some category of secrecy or integrity
  - labels are sets of tags
  - a process $p$ has 2 labels, $S_p$ for secrecy and $I_p$ for integrity
    - if $t \in S_p$ then (conservatively) $p$ saw private data tagged with $t$
    - if $t \in I_p$ then every input to $p$ has been endorsed as having
      integrity for $t$
  - two capabilities per tag
    - $t+$: ability to add $t$ to one of its label
    - $t-$: ability to remove $t$ from one of its label
    - note: you might not want to use the same $t$ for both secrecy and
      integrity; see examples below
  - each $p$ owns a set of capabilities $O_p$
  - $D_p = { t \vert t+ \in O_p, t- \in O_p }$ (the set of tags for which $p$
    has dual privileges)
  - any $p$ can create tags; added to $D_p$
  - global capability set $O \subseteq O_p \forall p$
- export protection example
  - if $b \in S_p$ then $p$ can write to $q$ iff $b \in S_q$ also
  - but _any_ process can add $b$ and read secret $b$ since $b+ \in O$
    - means all their output will be tagged with $b$
    - note that this means $b$ should not be used for integrity, or anyone can
      add it to their integrity label
  - but a process $p$ can't leak it out of system unless $b- \in O_p$
    - transition: from secret to non-secret
- integrity protection example
  - if $b \in I_p$ then $p$ can read from $q$ iff $b \in I_q$ also
  - processes cannot willy nilly add $b$ and be trusted to provide $b$-tagged
    data
    - transition: from non-trusted to trusted
    - this is called _endorsement_
  - can, however, remove $b$ to remove trust (not sure why they want to do
    that); so $b- \in O$

IE

- Protected Mode for isolation and sandboxing
- type 1 (reflected) xss filter

malware
-------

the ghost in the browser: analysis of web-based malware (provos, google, 2008)

- 10% of URLs engaged in drive-by downloads
  - map-reduce looks for known malicious URLs in corpus
  - instrumented IE in VM; watch for add'l processes, changes in FS/reg
- malware comes from lack of content control on pages
  - web app exploits
  - user content
  - ads: partner with dedicated ad companies, not individual advertisers; trust
    is not transitive
  - third-party widgets: eg stats counter, iframemoney.org
- exploits
  - popular: MS DAC
    - js instantiates activex object; normally not safe for scripting
    - js retrieves exe via XHR
    - adodb.stream used to write exe to disk
    - shell.application launches new exe
  - popular: MS WebViewFolderIcon heap spray
  - many gather info (eg browser, jvm version, OS patches) then fetches
    applicable exploits
  - can also trick user, eg video activex codec
- trends
  - js escaping: effective against signature/anomaly-based IDSs; also used by
    legit sites
  - classification: use majority voting by major AV software
    - trojan: contains/installs malicious app with harmful impact on user's
      computer
      - most common: downloaders (get other trojans), banking (bank acct
        numbers, passwds)
    - adware
    - unknown/obfuscated
  - http reqs not from browser: mostly for popup ads, some for updates/instrs
  - most exploits not hosted on compromised sites; distributed across many
    sites
  - hosted binaries mostly change infrequently; some do, to evade sig scans
- most malware are user-mode apps
- [curiously, saw nothing on spam]

a crawler-based study of spyware on the web (uw, 2007)

- downloaded exe's, ran/install in VM, ID with lavasoft ad-aware
- twice: 5/2005, 10/2005
- high risk sites: games, celebs
- types
  - adware
  - keylogging spyware
  - trojan downloaders
  - browser hijackers: search engine, default home page, URL redirection
  - dialers: uses modem to call expensive toll numbers
  - mostly adware, hijackers (relatively benign) but many downloaders
  - drive-by's have same distribution as spyware
- time comparisons: older AV DB misses 1/3 of spyware; URL blacklisting
  ineffective [numbers don't seem to support, though]
- many tweak registry
- collection via disposable webmail
- [notes]
  - curiously, saw nothing on spam, game passwd harvesting
  - no need for exploits

systems security
----------------

return-oriented programming (Hovav Shacham, ucsd, 2009)

- generalization of return-to-libc; chain `ret`s together
- [not much here]

"Countering Kernel Rootkits with Lightweight Hook Protection"

- gist: copy all hooks to read-only mem and make all callsites (found by
  profiling) use that
- premise: preserving kernel code integrity (eg disallowing changing kernel
  code and disallowing introduction of new code) is not enough
  - exploits leverage existing code and subvert control flow, eg return
    addresses and function pointers
  - protecting return addresses is well studied
  - this paper: protecting function pointers (hooks)
- profile system offline to find out the calling sites of all hooks, or _hook
  access points (HAPs)_
  - given the list of kernel hook locations for protection (globals)
  - dynamically allocated hooks: discovered at runtime by monitoring call stack
    at alloc sites to see what object is being created
- online system protection: run OS in hypervisor (Xen)
  - after OS init, copy all hooks into a memory region; these copies are the
    _shadow hooks_
    - region is read-only
    - read/write requests distinguished by HAP
    - hypervisor validates write request (requires new hook value to be
      recognized from offline profiling phase, but other validations possible)
  - dynamically allocated hooks: alloc/update/free results in hypercall
  - memory protection is guaranteed by hypervisor shadow page table
  - trampoline the HAPs to call into shadow hook area
    - (as typical) the instructions are in read-only executable text pages
  - syscall table can be uniquely optimized

seminal
-------

Why Isn't Trust Transitive? (bruce christianson, william s harbison)

- straightforward but classic

Sandboxing
----------

privsep (niels provos, usenix 03)

- privileged parent monitor and unprivileged child process
- no syscall tracing; only using OS UID-based privilege separation
- child runs with unused user and chroot'd to /var/empty
- comm over pipes, shared mem

Efficient Software-Based Fault Isolation (Wahbe, sosp93)

- can isolate via separate addr spaces, but switches not good for tightly
  coupled modules
  - RPC: trap, copy, ctx save/restore, switch HW addr space (flush TLB), trap
    - repeat on return; 3 OOM > normal proc call
  - eg postgres extensible type system can define ctors, dtors, preds
  - eg OS exts: packet filters, app-specific virt mem mgmt, Active Messages
- propose a portable, PL-indep approach:
  - load code/data into own _fault domain_ (portion of host's addr space)
  - rewrite code to prevent writes/jumps outside fault domain
- poses tradeoff rel. to hardware fault isolation: substantially faster comm
  btwn fault domains, but slightly increased execution time for distrusted
  modules
  - evaluated on postgres; 3x faster than sep addr spaces

App-V (john sheehan, MS ECS 2009)

- _sequencing_: process of packaging apps
  - monitor installation from kernel; capture FS/reg changes
  - now know all the resources needed by app; can optimize the layout for
    streaming
  - extract metadata; eg recognize COM objs, NT services; store in manifest
  - heuristics
    - program files: don't need to roam with user
    - hkey_current_user keys: should roam with users
    - UI for tweaking these settings
- SystemGuard: "namespace mgr"
  - system namespace: fall-through for everything else
  - elseapp namespace: produced by sequencing
    - eg `C:\windows\system32\foo.dll` could've been installed by app
    - enables streaming (Click2Run), user roaming
  - modification namespace: where writes go (either roaming or non-roaming)
  - handles: files, reg, COM, fonts, services, object mgr, mailslots, etc.
    - eg virtualize CLSIDs for COMs; virtualize service names
    - don't deal with drivers; typically installed as part of platform
  - dynamic, not static: watch processes, not programs
    - eg cmd is already there, but if run via a VS shortcut, run it in the VS
      bubble
  - for cross-app, dynamic suite composition (DSC) feature: run in same bubble
- office doesn't user the generic app-v UIs

native client

- inner sandbox
  - software fault isolation
    - in general disassembly is unreliable: same instruction stream may be
      entirely different if you jump to somewhere in the middle of it
    - goal: get reliable disassembly; then, can prohibit certain instructions
    - static validation of most calls/jumps
    - once loaded, binary is not writable; also uses x86 segments to constrain
      the executable instruction range
    - locates instructions at address 0 so that indirect jumps need only be
      prefixed by an `and` and not an `and;or`
    - omit certain instructions: ret, int, syscall; use indirect jumps
    - all indirect branch targets must be aligned; bitmask every target
      address
    - no code gen, mixed text/data, overlapping instrs
  - x86 segments: hardware support -> faster
    - original SFI: bitmask every load/store address
    - caveat: need LDT; privileged instruction, vista 64 doesn't provide this;
      confuses os an hardware exceptions
- outer sandbox
  - redundant; defense in depth
  - system call filter for untrusted modules
  - OS-dependent: ptrace on linux, syscall ACLs on Windows
    - to avoid ptrace overhead, nacl provides own shared mem and sync objects
- compile for native client with modified gcc (1000 lines patched)

Sprockets: Safe extensions for distributed file systems (umich usenix 07)

- for distributed FS "tweak" extensions; DFSs mostly impl'd in user space
  - run procedure in same addr space, then always roll back except for the
    buffer expecting results (this is validated/acted on by host)
  - programmability like proc call: lightweight usage, can access any data/code
  - cost: not up front per sprocket, but per line of code executed, since
    sprockets are small
- alt designs and their problems
  - direct procedure call: same addr space
  - separate addr spaces, eg fastcgi
    - no access to (reuse of) data/code; need to define (read) interface
    - requires OS fine-grained sandboxing (only read file1 and write file2)
  - chkpt/rollback (fork): closest to sprockets
    - heavy; still requires OS sandboxing
    - idea for multithreading: wait for all locks to release before fork
- binary instrumentation/SFI with PIN
  - first save caller ctx (regs, PC, heap size, etc)
  - for each mem write, save orig loc/val in undo log
  - dynamically enable/disable instrumentation: core FS functions called via
    sprockets are instrumented; outside, orig is used
  - OOM slower, but faster than fork
  - optims: no need to restore unused memory, eg space below stack or malloc'd
    by sprocket; avoid dup backups
- handling buggy sprockets
  - register sig handlers for segfaults, timeouts
  - instrument syscalls with check against whitelist + optional specific
    syscall handling (eg closing an fd that it didn't open)
- multithreading: sprocket time (.14-.62ms) << scheduling quantum
- implemented: transducers (id3), app-specific resolution (id3), devices (PTP)
- related work
  - wahbe: limits access to addr space outside sandbox
  - vino: SFI for OS exts; not full access (whitelist of kernel fn's)
  - nooks: used this technique for device drivers
  - exokernel: allows user-level code to impl many services
  - sprockets target functionality already avail. at user-level; min changes;
    user-level tools/libs
  - type-safe langs: eg SPIN OS uses modula-3; limits FS code reuse (mostly not
    in type-safe langs)
  - watchdogs, stackable FSs: more coarse-grained ext interface allowing exts
    only at certain pre-defined VFS ops like open, close, write
  - may leverage STM/HTM techniques

Saltzer & Schroeder, "The Protection of Information in Computer Systems"

- seminal paper on OS security
- no mention of pub key crypto; still 5 yrs away

chrome/chromium

- chroot: requires suid but is ironically more secure
- exec()ing from empty jail is hard
  - can copy all dep files, but maintenance/packaging nightmare
  - use clone() flag CLONE_FS and share FS struct btwn a trusted/privileged
    thread and the exec()ed renderer
  - trusted thread can call chroot and have it affect the unprivileged,
    untrusted renderer post-exec
- CLONE_NEWPID and CLONE_NEWNET: prevent sending signals, network access
- <http://scarybeastsecurity.blogspot.com/2009/10/chromium-and-linux-sandboxing.html>

Security In-Depth for Linux Software: Preventing and Mitigating Security Bugs (Julien Tinnes, Chris Evans, Google, Hack in the Box 10/2009)

- examples: chromium, vsftpd
- security in depth
  - reduce bugs
  - app-level mitigation (SSP, relro)
  - sys-level mitigation (ASLR, NX)
  - privilege dropping (sandboxing)
  - mandatory access control (MAC)
  - update strategy
- privileges in linux: processes and privileges
  - kernel is a mandatory interface to system; process is privilege boundary
  - A > B if A's privileges are superset of B's
  - procs have uid + gid
  - threads *generally* don't have privilege separation (but: clone, seccomp)
  - if A can ptrace B, then A > B
  - uids/gids
    - types
      - real: owner; who you really are; only root (usu. login) can change; `id -ru`
      - effective: for access ctl; `id -un`
      - saved: 
      - FS: file system; in linux
    - operations
      - fork inherits UIDs
      - suid + seteuid let you temporarily drop root and restore later
      - not sure if correct (prolly not):
        - `setuid(x) = if (euid == 0) { ruid = euid = suid = x } else { euid = x }`
        - `seteuid(x) = if (euid == 0) { ruid = euid = suid = x } else { euid = x }`
    - summary
      - (r)uid, euid, suid, fsuid
      - (r)gid, egid, sgid, fsgid, supplementary groups
  - POSIX.1e capabilities: for splitting root privileges; in linux 2.2
  - partial uid switching
    - mostly useful to avoid confused deputy problems
    - useless given arbitrary code execution
    - only root can use
  - linux capabilities
    - CAP_NET_RAW: permit use of RAW and PACKET sockets
    - CAP_SYS_ADMIN: administrative ops (mount, sethostname, etc)
    - CAP_NET_BIND_SERVICE: binding to reserved ports (<1024)
  - common mistakes
    - forgetting to switch from uid 0
  - chroot: popular way to drop FS access; root only
    - requires dropping privileges afterward, or easy to escape
    - re-chroot technique (popular), inject modules, ptrace non-chroot-ed proc,
      etc
    - look at capabilities for inspirations of other things you can do as root
      to escape
  - recent kernels add clone/unshare flags for dropping privileges; root only
    - CLONE_NEWPID: new pid namespace
    - CLONE_NEWNET: new network namespace
    - CLONE_NEWIPC, CLONE_NEWUTS, CLONE_NEWNS
  - resource limits
    - RLIMIT_NOFILE: can't get new fd's, but can still rename and unlink
    - RLIMIT_NPROC: can't create new procs
    - if used for security, both soft and hard limit need to be set to 0
    - or attacker could replace existing fd to create new fd's
  - linux supports per process dumpable (debuggable) flag
    - can be set through
      - prctl with PR_SET_DUMPABLE
      - when executing a file you don't own and can't read
      - when switching uid
    - CAP_SYS_PTRACE: can't ptrace a non dumpable proc; thus, elevation of
      privileges
    - allows to lower another process' privileges
- writing good code
  - preventing common security flaws
  - privilege separation
  - trust relationships
  - update strategy
- sandbox designs
  - ptrace
  - setuid
  - SECCOMP
  - other
  - attack surface eval

Xax (MSR)

- mechanisms
  - picoprocess: native-code execution abstraction that is secured via hardware
    memory isolation and a narrow syscall interface, akin to streamlined
    hardware VM
  - PAL: provides an OS-indep ABI to xax picoprocesses
  - hooks to existing browser mechanisms to provide aps with system services
    (network, UI, storage) that respect browser security policies
  - lightweight modifications to existing tool chains and code bases for
    retargeting legacy code to the xax picoprocess env
- goals and alternatives
  - goals: security, OS indep, perf, and legacy support
    - [they compare SF LOC of C/C++ vs. others; this disregards verbosity, the
      projects themselves, etc.; may have been better to count number of
      projects]
  - alternatives
    - existing web-app mechanisms
      - js: slow; no legacy code
      - activex: no sandboxing; only a way to package app for invoking via web;
        windows only
      - IL (flash/java/MSIL): no legacy code
    - OS processes: not OS indep, insufficient sec
      - can write interposing confinement layers, but that's hard
      - xax goes opposite: start with no interface and add
    - hardware vm's: big/complex, so slow dl, insecure, hard to write
      - xax = extreme paravirt where guest os is removed
      - reduces vmm also: no emulation of devices, mmu, cpu kernel mode
- mechanisms
  - picoprocess: VM without devices, MMU, CPU kernel mode
    - alternatively, a highly restricted proc prevented from making kernel calls
    - hardware-memory-isolated address space; strictly user-mode CPU
    - xax monitor: browser plugin; picoprocess makes xaxcalls to this
    - xaxcalls vary slightly among platforms to keep xax monitor simple
  - platform abstraction layer (PAL) for OS indep
    - PAL translates OS-indep ABI to OS-specific xaxcalls
    - PAL runs inside picoprocess; untrusted; everything above ABI is remote
    - only 9 calls in xax abi
    - simple shim libxax that converts app dev toolchain's calling convention
      into xax ABI calls into PAL
  - services via browser mechanisms: same security policies
    - picoprocess is web server; serves http requests
  - lightweight code modification: 5 steps to addressing all porting issues
    - TODO
    - obliviously failing
    - emulate syscall functionality internally
      - eg fs: read from tar, write to ramdisk; also read from other files, eg
        downloaded from server
    - provide real syscall functionality via xaxcalls
      - real backing functionality for remaining 137 syscalls (11 unique)
- implementation
  - monitor, boot block, PAL
    - monitor is its own process; xaxcalls via shared mem
    - boot block sets up shared mem, makes kernel call to revoke ability to make subsequent kernel calls, and continues into PAL (which loads/executes app)
    - most xaxcalls implemented straightforwardly in similar way on both platforms
  - linux: uses ptrace to intercept entry/exit of every syscall and xfer control to monitor
    - monitor replaces syscall with effectless getpid
    - syscalls also used by pal to signal a xaxcall; monitor checks if shared memory contains legit xaxcall id/args
    - for alloc/free, replace syscall with mmap; this is because monitor can't alloc mem on behalf of child
    - 3 syscalls (slow); also if monitor crashes then child can make syscalls
      - fix by using kernel module
  - windows: custom kernel module xaxdrv
    - each windows thread has pointer to table of syscall handlers; xaxdrv replaces this
      - in replacement table, if caller is kernel mode, then pass through preserving dispatcher's stack frame; else, xaxcall
    - monitor can alloc/free on behalf of child
    - easy to port to many windows; just change some pointer values
    - could also have patched every entry in std syscall table, but discouraged since it affects every process i the system
  - loaders: have elf and pe-coff loaders
  - browser integration: local server appears as same origin; most URL requests go through to host but `/_xax/` refers to existing/new picoprocess
- examples
  - headline reader (audio) and 3D demo (10 fps) shows we can deliver rich content
  - social network visualizer shows utility of leveraging existing graphviz legacy code
  - ghostscript (pdf) and kaffe (jvm) shows this can replace browser plugins
- evaluation
  - performance: high xaxcall overhead; fast(er) as java; much faster than v8
  - legacy: apps use 15 libs totaling 3.3M loc in 4 langs with minimal changes
  - os-indep: linux & many windows
  - security: trusted code base (TCB) less tha jvm/flash
- related work
  - TODO
- limitations
  - threading: need a new xaxcall for spawing & asynchronous signaling
  - porting more mainstream C libs like glibc/MS is harder since they rely on
    x86 segment registers to manage thread-local storage, which can't be
    assigned in user mode, so must emulate or obviate this functionality
  - port more interactive code: GUI libs with few deps (qt/embeded); blit frame
    buffers; keyboard/mouse events catpure in js

umview

- linux sandboxing tool; uses ptrace
- tried contributing some kernel patches for ptrace perf (pmulti)

web
---

forcehttps

- stricter https error processing; treat errors not as possible misconfigs but
  as attacks
- prohibit mixed http/https
- simple url rewriting rules: //foo.com/blah gets the current http/https
  prepended

low-level
---------

MODERN EXPLOITATION AND MEMORY PROTECTION (alexander sotirov)

- memory corruption vulns: stack cookies/canaries, NX mem, ASLR
- windows mitigations: GS, SafeSEH, DEP, ASLR, SEHOP
- vuln classes: stack overflows, heap overflows, fmt strings, int overflows
- assumptions
  - fixed addrs of stack & exes
  - fn ptrs at well-known locs
  - heap allocator that trusts heap metadata
  - executable data on stack and heap
- mitigations
  - GS: stack cookies, var reordering, strict_gs_check
  - safeseh: handler chain, validation
  - heap protection: safe unlinking, safe lookaside lists, heap metadata cookies, heap metadata encryption
  - DEP: NX support, permanent DEP, optout mode by default
  - ASLR: PEB/TEB, heap, stack, images
- detect mem corruption: GS stack cookies, SEH chain validation (SEHOP), heap
  corruption detection
- stop common exploitation patterns: GS var reordering, safeseh, DEP, ASLR
  - rand cookie is generated every run; xor fn ptrs w rand cookie; code that
    uses the fn ptr xor's
- cookies
  - perf impact to cookies
  - ways to bypass; addressed by reordering; still a few special case vulns (eg
    overriding EHs, fmt strings)
- safeseh is a list of valid exception handlers which is checked before jumping
  to an exception handler
  - however, requires all DLLs to be compiled using SEH; single non-compat DLL
    is enough to bypass protection
  - control flow modification still possible
- SEH chain validation (SEH override protection aka SEHOP)
  - each stack frame is chained by a linked list
  - put random cookie at end of linked list
  - on exception, walk entire list and validate that the end of list has cookie
  - if SEH record is overwritten, SEH chain will break and cookie won't be found
  - no known bypasses
  - exception handling is already pretty slow by design
- DEP: off by default for compat reasons (eg JVM)
  - IE8 finally turned on DEP for plugins
  - return oriented shellcode (ret2libc): DEP w/o ASLR is completely useless
